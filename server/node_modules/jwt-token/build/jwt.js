"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const refresh_token_1 = require("./refresh-token");
const jwt_token_1 = require("./jwt-token");
const jwt_error_1 = require("./jwt-error");
class Jwt {
    static async getTokenOrCreateTokens(payload, refreshTokenOption, createAccessTokenOption, getRefreshToken, saveRefreshToken, updateRefreshToken) {
        const result = {};
        const accessToken = new jwt_token_1.JwtToken({
            payload,
            ...createAccessTokenOption,
        });
        result.accessToken = accessToken;
        const savedRefreshToken = await getRefreshToken(payload);
        if (savedRefreshToken === undefined) {
            const refreshToken = new refresh_token_1.RefreshToken({
                payload,
                ...refreshTokenOption,
            });
            await saveRefreshToken(refreshToken);
            result.refreshToken = refreshToken;
        }
        else {
            try {
                const refreshToken = new refresh_token_1.RefreshToken({
                    token: savedRefreshToken,
                    ...refreshTokenOption,
                });
                if (refreshToken.refreshRefreshTokenIfPossible({
                    payload,
                    ...refreshTokenOption,
                })) {
                    await updateRefreshToken(refreshToken);
                }
                result.refreshToken = refreshToken;
            }
            catch (_) {
                const refreshToken = new refresh_token_1.RefreshToken({
                    payload,
                    ...refreshTokenOption,
                });
                await updateRefreshToken(refreshToken);
                result.refreshToken = refreshToken;
            }
        }
        return result;
    }
    static async verifyAccessToken(decodeAccessTokenOption, getManuallyChangedAt) {
        const accessToken = new jwt_token_1.JwtToken({
            ...decodeAccessTokenOption,
        });
        const manuallyChangedAt = await getManuallyChangedAt(accessToken);
        if (manuallyChangedAt === undefined) {
            throw new jwt_error_1.JwtError(jwt_error_1.JwtError.ERROR.NO_MANUALLY_CHANGED_AT);
        }
        else if (manuallyChangedAt > accessToken.decoded.iat) {
            throw new jwt_error_1.JwtError(jwt_error_1.JwtError.ERROR.CREATED_BEFORE_BEING_MANUALLY_CHANGED);
        }
        return accessToken.decoded.payload;
    }
    static async refresh(refreshTokenString, refreshTokenOption, accessTokenOption, getRefreshToken, updateRefreshToken) {
        const result = {};
        const refreshToken = new refresh_token_1.RefreshToken({
            token: refreshTokenString,
            ...refreshTokenOption,
        });
        const resultOfGetRefreshToken = await getRefreshToken(refreshToken);
        if (resultOfGetRefreshToken === undefined) {
            throw new jwt_error_1.JwtError(jwt_error_1.JwtError.ERROR.NO_RESULT_OF_GET_REFRESHTOKEN);
        }
        else if (resultOfGetRefreshToken.manuallyChangedAt > refreshToken.decoded.iat) {
            throw new jwt_error_1.JwtError(jwt_error_1.JwtError.ERROR.CREATED_BEFORE_BEING_MANUALLY_CHANGED);
        }
        const savedRefreshToken = new refresh_token_1.RefreshToken({
            token: resultOfGetRefreshToken.refreshToken,
            ...refreshTokenOption,
        });
        const payload = savedRefreshToken.decoded.payload;
        if (savedRefreshToken.refreshRefreshTokenIfPossible({
            payload,
            ...refreshTokenOption,
        })) {
            await updateRefreshToken(savedRefreshToken);
        }
        result.refreshToken = savedRefreshToken;
        const accessToken = new jwt_token_1.JwtToken({
            payload: savedRefreshToken.decoded.payload,
            ...accessTokenOption,
        });
        result.accessToken = accessToken;
        return result;
    }
}
exports.Jwt = Jwt;
